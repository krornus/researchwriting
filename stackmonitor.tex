\documentclass{article}

\title{Vulnerability Auditing Through Live Stack Tracing}
\author{Spencer Powell}
\date{\today}

\begin{document}

\maketitle

\section{Stack Monitor}

The stack monitor is a tool that was written in order to create logs of stack activity for arbitrary programs. This means that the vulnerability auditing will be dynamic, instead of static. Dynamic execution has a few issues with it that must be dealt with. One of the biggest issues with dynamic execution traces is that of code coverage. Identifying a vulnerability requires that you first execute the vulnerable piece of code. We have elected to use fuzzing as a technique for code coverage, as it is well researched and there are many preexisting methods with which to explore a binary. The monitor takes a binary executable of a program (currently only 64 bit x86 ELF's are supported). The monitor produces a sequence of stack read and write operations which can be accessed through python. It also produces an instruction trace of the program, and information about the location and size of the stack in memory per instruction. Currently this information is placed into a log, illustrated in Figure 1.1. Because the data from the monitor is analyzed through machine learning, the data must be preprocessed. The addresses of the stack operations are made to be relative to the base pointer, and the stack frame is given in an overall size instead of both a stack and base pointer.

\section{Key Technical Challenge}

The key technical challenge of this tool is handling the massive amount of data. Per instruction, the log contains three addresses, and extra optional data for memory operations on the stack. This large influx of data is handled in two distinct methods. The first method is a binary debugger which attempts to extract and call a given function from a binary. This allows us to limit our scope of analysis to a single area, and create multiple logs based on differing inputs. The second method used to handle the large dataset is machine learning. Our goal is to discover patterns in stack behavior could indicate vulnerable logic in a binary. There is far too much data for this to be done manually, so machine learning was applied.

\section{Workflow}

The workflow of the program is as follows. The program takes a binary file, which is sent to the stack monitor. The stack monitor spawns a binary debugger, which will call functions within the program itself. Each function run is monitored and the output is stored in a log. The debugger is capable of giving arguments to the given function, which can be randomized. Previously known fuzzing techniques can be applied to these functions, in an effort to trigger crashes.

\end{document}
